module Main where

import Prelude

import Data.Array (range)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Halogen.VDom.Driver (runUI)

main :: Effect Unit
main = HA.runHalogenAff do
  body <- HA.awaitBody
  runUI component unit body

-- How to tie West to col, North to row and vice versa?

data Heading = North | South | East | West
instance showHeading :: Show Heading where
  show North = "North"
  show South = "South"
  show East = "East"
  show West = "West"

type Position = { row::Int,col::Int }
type State = { position::Position, heading::Heading }
data Action = Forward | CW | CCW

move :: State -> State
move state@{ position:{row,col},heading } =
  case heading of
    North
      | row > 1 -> state { position { row = row - 1 } }
      | otherwise -> state
    South
      | row < 5 -> state { position { row = row + 1 } }
      | otherwise -> state
    East
      | col < 5 -> state { position { col = col + 1 } }
      | otherwise -> state
    West
      | col > 1 -> state { position { col = col - 1 } }
      | otherwise -> state

turnCW :: Heading -> Heading
turnCW heading =
  case heading of
    North -> East
    South -> West
    East -> South
    West -> North

turnCCW :: Heading -> Heading
turnCCW = turnCW <<< turnCW <<< turnCW

-- Grid Module
grid :: forall w i. State -> HH.HTML w i
grid { position,heading } =
  HH.div
    [ HP.classes [ HH.ClassName "grid" ] ]
    (map 
      (\c ->
        if (eq position c) then
          HH.div
            [ HP.classes [ HH.ClassName "cell" ] ]
            [ HH.img [ HP.src ("/robot-" <> (show heading) <> ".svg"), HP.classes [ HH.ClassName "robot" ] ] ]
        else
          HH.div [ HP.classes [ HH.ClassName "cell" ] ] [ ])
      (range 1 5 >>= \n -> [{ row:n,col:1 }, { row:n,col:2 }, { row:n,col:3 }, { row:n,col:4 }, { row:n,col:5 }]))

component :: forall query i o monad. H.Component HH.HTML query i o monad
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
  where
  initialState :: forall input. input -> State
  initialState _ = { position:{ row:3,col:3 }, heading:East }

  -- takes State to render HTML which ultimately calls on an Action
  render :: forall mo. State -> H.ComponentHTML Action () mo
  render state =
    HH.div_
      [ HH.button [ HE.onClick \_ -> Just Forward ] [ HH.text "+" ]
      , HH.div_ [ HH.text $ show state.position, HH.text $ show state.heading ]
      , HH.button [ HE.onClick \_ -> Just CW ] [ HH.text "->" ]
      , HH.button [ HE.onClick \_ -> Just CCW ] [ HH.text "<-" ]
      , grid state
      ]

  -- takes an Action (as generated by ComponentHTML) and updates the State
  handleAction :: forall output m. Action -> H.HalogenM State Action () output m Unit
  handleAction action =
    case action of
      Forward ->
        H.modify_ \state -> move state
      CW ->
        H.modify_ \state -> state { heading = (turnCW state.heading) }
      CCW ->
        H.modify_ \state -> state { heading = (turnCCW state.heading) }