module Main where

import Prelude

import Data.Array (range)
import Data.Maybe (Maybe(..))
import Effect (Effect)
import Effect.Aff.Class (class MonadAff)
import Halogen as H
import Halogen.Aff as HA
import Halogen.HTML as HH
import Halogen.HTML.Properties as HP
import Halogen.Query.EventSource (eventListenerEventSource)
import Halogen.VDom.Driver (runUI)
import Web.Event.Event as E
import Web.HTML (window) as Web
import Web.HTML.HTMLDocument as HTMLDocument
import Web.HTML.Window (document) as Web
import Web.UIEvent.KeyboardEvent (KeyboardEvent)
import Web.UIEvent.KeyboardEvent as KE
import Web.UIEvent.KeyboardEvent.EventTypes as KET

main :: Effect Unit
main = HA.runHalogenAff do
  body <- HA.awaitBody
  runUI component unit body

-- How to tie West to col, North to row and vice versa?

data Heading = North | South | East | West
instance showHeading :: Show Heading where
  show North = "North"
  show South = "South"
  show East = "East"
  show West = "West"

type Position = { row::Int,col::Int }
type State = { position::Position, heading::Heading }
data Action = Init
            | HandleKey H.SubscriptionId KeyboardEvent

move :: State -> State
move state@{ position:{row,col},heading } =
  case heading of
    North
      | row > 1 -> state { position { row = row - 1 } }
      | otherwise -> state
    South
      | row < 5 -> state { position { row = row + 1 } }
      | otherwise -> state
    East
      | col < 5 -> state { position { col = col + 1 } }
      | otherwise -> state
    West
      | col > 1 -> state { position { col = col - 1 } }
      | otherwise -> state

turnCW :: Heading -> Heading
turnCW heading =
  case heading of
    North -> East
    South -> West
    East -> South
    West -> North

turnCCW :: Heading -> Heading
turnCCW = turnCW <<< turnCW <<< turnCW

-- Grid Module
grid :: forall w i. State -> HH.HTML w i
grid { position,heading } =
  HH.div
    [ HP.classes [ HH.ClassName "grid" ] ]
    (map 
      (\c ->
        if (eq position c) then
          HH.div
            [ HP.classes [ HH.ClassName "cell" ] ]
            [ HH.img [ HP.src ("/robot-" <> (show heading) <> ".png"), HP.classes [ HH.ClassName "robot" ] ] ]
        else
          HH.div [ HP.classes [ HH.ClassName "cell" ] ] [ ])
      (range 1 5 >>= \n -> [{ row:n,col:1 }, { row:n,col:2 }, { row:n,col:3 }, { row:n,col:4 }, { row:n,col:5 }]))

component :: forall query i o monad. MonadAff monad => H.Component HH.HTML query i o monad
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction, initialize = Just Init }
    }
  where
  initialState :: forall input. input -> State
  initialState _ = { position:{ row:3,col:3 }, heading:East }

  -- takes State to render HTML which ultimately calls on an Action
  render :: forall mo. State -> H.ComponentHTML Action () mo
  render state =
    HH.div_ [ grid state ]

  -- takes an Action (as generated by ComponentHTML) and updates the State
  handleAction :: forall output m. MonadAff m => Action -> H.HalogenM State Action () output m Unit
  handleAction = case _ of
    Init -> do
      document <- H.liftEffect $ Web.document =<< Web.window
      H.subscribe' \sid ->
        eventListenerEventSource
          KET.keyup
          (HTMLDocument.toEventTarget document)
          (map (HandleKey sid) <<< KE.fromEvent)
    HandleKey sid ev
      | KE.key ev == "ArrowUp" -> do
        H.liftEffect $ E.preventDefault (KE.toEvent ev)
        H.modify_ \state -> move state
      | KE.key ev == "ArrowLeft" -> do
        H.liftEffect $ E.preventDefault (KE.toEvent ev)
        H.modify_ \state -> state { heading = (turnCCW state.heading) }
      | KE.key ev == "ArrowRight" -> do
        H.liftEffect $ E.preventDefault (KE.toEvent ev)
        H.modify_ \state -> state { heading = (turnCW state.heading) }
      | otherwise ->
          pure unit